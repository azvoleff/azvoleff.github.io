---
layout: post
title: "Cloud removal with teamlucc"
description: "How to use the teamlucc R package to remove thick clouds in Landsat imagery"
category: articles
tags: [R, teamlucc, remote sensing, Landsat]
comments: true
modified: 2014-05-09
share: true
---

## Overview

This post outlines how to use the `teamlucc` package to remove thick clouds from Landsat 
imagery using the Neighborhood Similar Pixel Interpolator (NSPI) algorithm by 
[Zhu et al.](ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6095313)[^1]. 
`teamlucc` includes the original 
[IDL](http://www.exelisvis.com/ProductsServices/IDL.aspx) code by [Xiaolin 
Zhu](http://geography.osu.edu/grads/xzhu/). For R to be able to run (modified 
slightly to be called from R) as well as a native R/C++ implementation of the 
original NSPI algorithm. Thanks to Xiaolin for permission to redistribute this 
code along with the `teamlucc` package.

[^1]:
    Zhu, X., Gao, F., Liu, D., Chen, J., 2012. A modified neighborhood similar 
    pixel interpolator approach for removing thick clouds in Landsat images. 
    Geoscience and Remote Sensing Letters, IEEE 9, 521â€“525. 
    doi:10.1109/LGRS.2011.2173290


## Getting started

First load the `teamlucc` package, and the `SDMTools` package we will use 
later:

```{r}
library(teamlucc)
library(SDMTools)
```

If `teamlucc` is not installed, install it using `devtools`"

```{r}
if (!require(teamlucc)) install_github('azvoleff/teamlucc')
```

## Simplest approach: cloud fill a single clouded image with a single clear image

This example will use a portion of a 1986 Landsat 5 scene from Volcan Barva, 
Costa Rica (a [TEAM 
Network](http://www.teamnetwork.org/network/sites/volc%C3%A1n-barva) monitoring 
site). The scene is WRS-2 path 15, row 53. Particularly in the tropics, it can 
sometimes be difficult to find a Landsat image that is cloud-free. Cloud 
filling can offer a solution to this problem if there are multiple Landsat 
scenes captured of an area of interest, that, taken together, offer a 
cloud-free (or nearly cloud-free) view of an area. Throughout this post I will 
refer to the "base" and the "fill" images. The "base" image is a cloudy image 
that will be filled using images (the "fill images) of the same area that were 
captured on different dates.

While it can sometimes be possible to find a cloud-free scene from a different 
part of the year that can be used to fill in a cloudy scene from an earlier or 
later base date, it is often the case that both the fill and base image will 
have clouds. Therefore we must use cloud masks to mark areas in both the base 
and the fill image. Without a cloud mask for the fill image we could otherwise 
inadvertently fill clouded areas in one image with also cloudy pixels from 
another image.

The base (cloudy) image for this example is from January 5, 1986, and the fill
image is from January 21, 1986.  The images are surface reflectance images from 
the [Landsat Surface Reflectance Climate Data Record 
(CDR)](http://landsat.usgs.gov/CDR_LSR.php), that also include cloud masks 
constructed with the [Function of Mask (fmask) 
algorithm](https://code.google.com/p/fmask)[^2].

To follow along with this analysis, [download these 
files](/content/2014-04-16-cloud-removal-with-teamlucc/2014-04-16-cloud-removal-with-teamlucc.zip).  
Note that the original CDR reflectance images have been rescaled to range 
between 0 and 255 in the files supplied here (this rescaling is not required 
prior to performing cloud fill - I just did it here to make the files sizes 
smaller so they could be more easily hosted on this site).

[^2]:
    Zhu, Z. and Woodcock, C. E., Object-based cloud and cloud shadow detection 
    in Landsat imagery, Remote Sensing of Environment (2012), 
    doi:10.1016/j.rse.2011.10.028

### Load input data

First load the base and fill images into R:

```{r, cache=TRUE}
base <- brick('vb_1986_005_b234.tif')
fill <- brick('vb_1986_021_b234.tif')
```

Notice the cloud cover in the base image:

```{r, base_image, fig.cap='Base image', cache=TRUE}
plotRGB(base, stretch='lin')
```

The fill image also has cloud cover, but less than the fill image - there are 
areas of the fill that can be used to fill clouded pixels in the base image:

```{r, fill_image, fig.cap='Fill image', cache=TRUE}
plotRGB(fill, stretch='lin')
```

### Topographic correction

In mountainous areas, topographic correction should be performed prior to cloud 
fill[^1]. `teamlucc` supports performing topographic correction using 
algorithms derived from those in the `landsat` 
package](http://cran.r-project.org/web/packages/landsat/index.html) by Sarah 
Goslee[^3].

[^3]:
    [Sarah C. Goslee (2011). Analyzing Remote Sensing Data in R: The landsat 
    Package. Journal of Statistical Software, 43(4), 
    1-25.](http://www.jstatsoft.org/v43/i04/. )

To perform topographic correction, use the `topographic_corr` function in 
`teamlucc`. First load the slope and aspect rasters:

```{r, cache=TRUE}
slp_asp <- brick('vb_slp_asp.tif')
```

Now call the `topographic_corr` function twice, to topographically correct both 
the base and fill image. Note that the sun angle elevation and sun azimuth 
(both in degrees) must be supplied - values for these parameters can be found 
in the metadata accompanying your imagery. See `?topographic_corr` for more 
information.  `DN_min` and `DN_max` can be used to ensure that invalid values 
are not generated by the topographic correction routine (which can sometimes be 
a problem in very heavily shadowed areas, or in very bright areas, such as 
clouds).

```{r, cache=TRUE}
base_tc <- topographic_corr(base, slp_asp, sunelev=90-47.34, sunazimuth=134.04, 
                            DN_min=0, DN_max=255)
fill_tc <- topographic_corr(fill, slp_asp, sunelev=90-46.80, sunazimuth=129.88, 
                            DN_min=0, DN_max=255)
```

```{r base_tc, fig.cap='Base image after topographic correction'}
plotRGB(base_tc, stretch='lin')
```

```{r fill_tc, fig.cap='Fill image after topographic correction'}
plotRGB(fill_tc, stretch='lin')
```

### Construct cloud masks

The fmask band from the CDR imagery uses the following codes:

| Pixel type     |  Code  |
| -------------- | :----: |
| Clear land     |    0   |
| Clear water    |    1   |
| Cloud shadow   |    2   |
| Snow           |    3   |
| Cloud          |    4   |
| No observation |   255  |

We need to construct a mask of areas where all pixels that are cloud (code 4) 
or cloud shadow (code 2) are equal to 1, and where pixels in all other areas 
are equal to zero.  This is easy using raster algebra from the R `raster` 
package. First load the masks:

```{r, cache=TRUE}
base_fmask <- raster('vb_1986_005_fmask.tif')
fill_fmask <- raster('vb_1986_021_fmask.tif')
```
Now do the raster algebra, masking out clouds and cloud shadows, and setting 
missing values in both images to NAs in the masks:

```{r, cache=TRUE}
# Set mask to 1 in clouds and shadow areas
base_cloud_mask <- (base_fmask == 2) | (base_fmask == 4)
fill_cloud_mask <- (fill_fmask == 2) | (fill_fmask == 4)
# Set mask to NA in background areas
base_cloud_mask[base_fmask == 255] <- NA
fill_cloud_mask[fill_fmask == 255] <- NA
# Set mask to NA in NA areas in topographically corrected images (NAs can 
# result from topographic correction, generally in very dark areas or areas of 
# very high slope)
base_cloud_mask[is.na(base_tc[[1]])] <- NA
fill_cloud_mask[is.na(fill_tc[[1]])] <- NA
```

Plot these masks to double-check they align with the clouds in the images we 
viewed earlier:

```{r, base_cloud_mask, fig.cap='Base image cloud mask', cache=TRUE}
plot(base_cloud_mask)
```

```{r, fill_cloud_mask, fig.cap='Fill image cloud mask', cache=TRUE}
plot(fill_cloud_mask)
```

Now use these two masks to mask out the clouds in the fill and base images, by 
setting clouded areas to zero (as the `cloud_remove` code treats pixels with 
zero values as "background":

```{r, cache=TRUE}
base_tc[base_cloud_mask] <- 0
fill_tc[fill_cloud_mask] <- 0
```

The cloud mask for the base image must be constructed so that each cloud has 
its own unique integer code, with codes starting from 1. This process can be 
automated using the `ConnCompLabel` function from the `SDMTools` package.  
However, because there are clouds in our fill image as well as in our base 
image, we need to modify the `base_cloud_mask` slightly to account for this. 
First, code all pixels in `base_cloud_mask` that are clouded in 
`fill_cloud_mask` with `NA`s. This will tell the `ConnCompLabel` function not 
to label these pixels as clouds (because they are also clouded in the fill 
image, we cannot perform cloud fill on these pixels).

```{r, cache=TRUE}
# Set clouds in fill image to NA in base mask:
base_cloud_mask[fill_cloud_mask] <- NA
# Set missing values in fill image to NA in base mask:
base_cloud_mask[is.na(fill_cloud_mask)] <- NA
```

Now run `ConnCompLabel`, and set the output datatype to `INT2S` (meaning the 
data in `base_cloud_mask` can range from -32768 - 32767). That said, please 
don't try to run cloud fill with 32,767 clouds in your image :).

```{r, cache=TRUE}
base_cloud_mask <- ConnCompLabel(base_cloud_mask)
```

The final `base_cloud_mask` is now coded as:

| Pixel type                       | Code    |
| -------------------------------- | :-----: |
| Background in `fill` or `base`   |   NA    |
| Clouded in `fill`                |   -1    |
| Clear in `base`, clear in `fill` |    0    |
| Clouded in `base`                | 1 ... n |

where n is the number of clouds in the image:

```{r, base_cloud_mask_recoded, fig.cap="Final base image cloud mask"}
plot(base_cloud_mask)
```

### Fill clouds

For this simple example, we will directly use the `cloud_remove` function in 
`teamlucc`. This function has a number of input parameters that can be supplied 
(see `?cloud_remove`). Two important ones to note are `DN_min` and `DN_max`.  
These are the minimum and maximum valid values, respectively, that a pixel in 
the image can take on. These limits are used to ignore unrealistic predictions 
that may arise in the cloud fill routine. For the base and fill images we are 
working with here, these values are 0 and 255, for max and min, respectively.  
Set these parameters to appropriate values as necessary for the images you are 
working with.

There are three different cloud fill algorithms that can be used from 
`teamlucc`. Two require an IDL installation, while the third uses a cloud fill 
algorithm that is native to R (though it is coded in C++ for speed reasons). 
The R-based algorithm is a bit more flexible than the IDL algorithms, and can 
handle images in which both the base and fill image have clouds. Based on the 
options supplied to `cloud_remove`, `teamlucc` wills select one of the three 
algorithms to run. The `use_IDL` and `fast` parameters to `cloud_remove` 
determine which cloud fill algorithm is used:

| `use_IDL` value | `fast` value | Algorithm used by `cloud_remove`               |
| :-------------: | :----------: | :--------------------------------------------: |
| `TRUE`          | `FALSE`      | CLOUD_REMOVE[^1]                               |
| `TRUE`          | `TRUE`       | CLOUD_REMOVE_FAST[^1]                          |
| `FALSE`         | `FALSE`      | `teamlucc` fill algorithm, based on Zhu et al. |
| `FALSE`         | `TRUE`       | Not yet supported                              |

First I will review the two IDL-based algorithms, then I will discuss the 
R-based version.

#### Cloud removal using IDL code

If run with `use_IDL=TRUE`, `cloud_remove` runs an IDL script provided by 
[Xiaolin Zhu](http://geography.osu.edu/grads/xzhu/). For R to be able to run 
this script it must know the path to IDL on your machine. For Windows users, 
this means the path to "idl.exe". To specify this path you will need to provide 
the `idl` parameter to the `cloud_remove` script. The default value 
(`C:/Program Files/Exelis/IDL83/bin/bin.x86_64/idl.exe`) may or may not work on 
your machine. I recommend you set the IDL path at the beginning of your 
scripts:

```{r, cache=TRUE}
idl_path <- "C:/Program Files/Exelis/IDL83/bin/bin.x86_64/idl.exe"
```

An optional `out_name` parameter can be supplied to `cloud_remove` to specify 
the filename for the output file. If not supplied, R will save the filled image 
as an R object pointing to a temporary file.

To run the cloud removal routine, call the `cloud_remove` function with the 
appropriate parameters. Note that this computation may take some time (it takes 
around 1.5 hours on a 2.9Ghz Core-i7 3520M laptop).

```{r, cloud_remove_IDL, cache=TRUE}
# # Takes 2-3 hours on a 2.9Ghz Core-i7 3520M laptop
# start_time <- Sys.time()
# # Ensure dataType is properly set prior to handing off to IDL
# dataType(base_cloud_mask) <- 'INT2S'
# base_filled <- cloud_remove(base_tc, fill_tc, base_cloud_mask, DN_min=0, 
#                             DN_max=255,
#                             idl=idl_path)
# Sys.time() - start_time
```

Use `plotRGB` to check the output. Note that IDL does not properly code missing 
values in the output - prior to plotting or working with the data be sure to 
set any pixels with values less than `DN_min` (here `DN_min` is zero) to `NA`:

```{r, cloud_remove_IDL_plot, cache=TRUE}
# base_filled[base_filled < 0] <- NA
# plotRGB(base_filled, stretch="lin")
```

The default cloud fill approach can take a considerable amount of time to run. 
There is an alternative approach that can take considerably less time to run, 
with similar results. This option can be enabled by supplying the `fast=TRUE` 
parameter to `cloud_remove`.

The "fast" version of the algorithm makes some simplifications to improve 
running time. Specifically, rather than follow the precise algorithm as 
outlined by Zhu et al.[^1], the "fast" routine uses k-means clustering to 
divide the image into the number of classes specified by the `num_class` 
parameter. The script then constructs a linear model of the temporal change in 
reflectance for each class within the neighborhood of a given cloud. This 
"temporal" adjustment is complemented by a "spatial" adjustment that considers 
the change in reflectance in a small neighborhood around each clouded pixel. 
For each clouded pixel, a weighted combination of the predicted fill values 
from the spatial and temporal models determines the final predicted value for 
that pixel. This version of the algorithm takes only 2.5 minutes to run on the 
same machine as used above:

```{r, cloud_remove_IDL_fast, cache=TRUE}
# Takes 2-3 minutes on a 2.9Ghz Core-i7 3520M laptop
start_time <- Sys.time()
# Ensure dataType is properly set prior to handing off to IDL
dataType(base_cloud_mask) <- 'INT2S'
base_filled_fast  <- cloud_remove(base_tc, fill_tc, base_cloud_mask, DN_min=0, 
                                  DN_max=255, idl=idl_path, fast=TRUE)
Sys.time() - start_time
```

Use `plotRGB` to check the output:

```{r, cloud_remove_IDL_fast_plot, cache=TRUE}
base_filled_fast[base_filled_fast < 0] <- NA
plotRGB(base_filled_fast, stretch='lin')
```

#### Cloud removal using native R code

If you do not have IDL on your machine, there is a C++ implementation of the 
NSPI cloud fill algorithm that will run directly in R. To run this version of 
the algorithm, call the `cloud_remove` function with the same parameters as 
above, but specify `use_IDL=FALSE`. This function also has a `verbose=TRUE` 
option to tell `cloud_remove` to print progress statements as it is running 
(this option is not available with the IDL scripts shown above):
This version is nearly identical to the IDL algorithm called with the 
`use_IDL=TRUE`, `fast=FALSE`, options set, but it takes much less time to run 
(only 3-4 minutes on my machine). This version of the cloud removal code is 
also able to properly handle imagery where there are missing pixels due to 
cloud cover in both the fill and clouded images. To use this routine, call 
`cloud_remove` with `use_IDL=FALSE`. Note that when `cloud_remove` is run with 
`use_IDL=FALSE` and `verbose=TRUE`, as in the below example, there will be a 
large number of status messages printed to the screeen. For the purposes of 
this demo, I have removed these output messages from this webpage - but don't 
be surprised if you see these messages when you try this command yourself.

```{r, cloud_remove_R, cache=TRUE, results='hide'}
# Takes 3-4 minutes on a 2.9Ghz Core-i7 3520M laptop
start_time <- Sys.time()
base_filled_R <- cloud_remove(base_tc, fill_tc, base_cloud_mask, DN_min=0, 
                              DN_max=255, use_IDL=FALSE, verbose=TRUE)
Sys.time() - start_time
```

View the results with `plotRGB`:

```{r, cloud_remove_R_plot, cache=TRUE}
plotRGB(base_filled_R, stretch='lin')
```

Because of the clouds in the fill image, not all of the clouds in the base 
image could be filled. To visualize which clouds were filled, and which were 
missed, you can use raster algebra:

```{r, cloud_remove_R_plot_filled_notfilled, cache=TRUE}
# Plot filled clouds
filled_clouds <- (base_filled_R > 0) & (base_cloud_mask > 0)
# Plot unfilled clouds
missed_clouds <- (base_filled_R <= 0) & (base_cloud_mask > 0)
evaluation <- stack(filled_clouds[[1]], missed_clouds[[1]])
names(evaluation) <- c("filled clouds", "missed clouds")
plot(evaluation)
```

#### Comparison of output from all three algorithms

To qualitatively compare the three algorithms, make a layer stack of the NIR 
band from all three images, and then plot:

```{r, cloud_remove_compare_algorithms, cache=TRUE}
par(mfrow=c(1,3))
#plotRGB(base_filled, stretch='lin')
plotRGB(base_filled_fast, stretch='lin')
plotRGB(base_filled_fast, stretch='lin')
plotRGB(base_filled_R, stretch='lin')
```
 
The left image was producted with `use_ID=TRUE`, the middle image with 
`use_ID=TRUE, fast=TRUE`, and the right image with `use_IDL=FALSE`.

Notice the fringing around the clouds in the northwest of the image, in the two 
images on the left that were filled with the `CLOUD_REMOVE` algorithm - this 
algorithm was not designed to handle images in which the fill image is also 
cloudy. I recommend using the R version of the algorithm (`use_IDL=FALSE`) in 
these cases.

## Advanced approach: automated cloud fill from an image time series

The `teamlucc` package also includes functions for automated cloud filling from 
an image time series. Automatic cloud filling is performed using the 
`auto_cloud_fill` function. This function automates the majority of the cloud 
filling process. As multiple images are required to demonstrate this process, 
the images required for this portion of the example are not available for 
download from this site. I suggest you download the appropriate imagery for a 
particular study site and preprocess the imagery using the `auto_setup_dem` and 
`auto_preprocess_landsat` functions in the `teamlucc` package so that you can 
follow along with this example. The `auto_preprocess_landsat` function will 
also perform topographic correction, which is necessary prior to cloud filling 
images in mountainous areas.

The `auto_cloud_fill` function allows an analyst to automatically construct a 
cloud-filled image after specifying: `data_dir` (a folder of Landsat 
images), `wrspath` and `wrsrow` (the WRS-2 path/row to use), and `start_date` 
and `end_date` (a start and end date limiting the images to use in the 
algorithm). The analyst can also optionally specify a `base_date`, and the 
`auto_cloud_fill` function will automatically pick the image closest to that 
date to use as the base image.

As the `auto_cloud_fill` function automatically chooses images for inclusion in 
the cloud fill process, it relies on having images stored on disk in a 
particular way, and currently only supports cloud fill for Landsat CDR surface 
reflectance images. To ensure that images are correctly stored on your hard 
disk, use the `auto_preprocess_landsat` function to extract the original 
Landsat CDR hdf files from the USGS archive. The `auto_preprocess_landsat` 
function will ensure that images are extracted and renamed properly so that 
they can be used with the `auto_cloud_fill` script.


```{r auto_cloud_fill, cache=TRUE}
# start_time <- Sys.time()
# start_date <- as.Date('1986-01-01')
# end_date <- as.Date('1987-01-01')
# filled_image <- auto_cloud_fill("C:/Data/LEDAPS_imagery", wrspath=230, 
#                                 wrsrow=62, start_date=start_date,
#                                 end_date=end_date, use_IDL=FALSE)
# Sys.time() - start_time
```
